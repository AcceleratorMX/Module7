package src.homeWork.h12;

class UniqueCharCounter {
    public int count(String phrase) {
        return phrase.replaceAll("(?i)(.)(?=.*?\\1)", "").length();
    }
}
/*
. соответствует любому символу
(...) создает группу захвата, на которую будут ссылаться позже
(?=...) создает внешний вид, чтобы смотреть вперед во входе
.*? соответствует любому символу и его совпадению (нежелательное соответствие)
\\1 соответствует первой группе захвата
(?i) устанавливает флаг без учета регистра

Итак, регулярное выражение будет искать любой символ, который будет иметь дубликат позже в строке, а затем replaceAll
заменит его на пустую строку. Таким образом, ввод типа "cabbacbdbadbcabdaadcb" становится "adcb" (сохраняя последний из
каждого уникального символа). Затем, когда строка содержит уникальные символы, эта длина строки является ответом.

Если по какой-то причине вам понадобилась строка уникального символа, и вам нужно было ее в первоначальном порядке,
вам пришлось бы отменить исходную строку перед удалением повторяющихся символов (а затем снова отменить ее,
когда закончите), Для этого потребуется либо сторонняя библиотека, либо StringBuffer, либо цикл.
*/

class UniqueCharCounterTest {
    public static void main(String[] args) {
        UniqueCharCounter charCounter = new UniqueCharCounter();

        //3
        System.out.println(charCounter.count("123"));

        //4
        System.out.println(charCounter.count("ab100"));

        //3
        System.out.println(charCounter.count("Java"));
    }
}
